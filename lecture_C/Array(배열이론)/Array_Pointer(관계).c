#include <stdio.h>


int main()
{
	/*
		배열의 이름(배열명)은 곧 주소이다.(포인터 상수)
		배열과 포인터의 관계
		- 배열은 첫 번째 원소의 메모리 주소를 저장하는 포인터
		- 포인터는 단순히 주소를 저장하는 변수
		  배열은 일정한 저장 공간을 가지고 있는 배열 형식의 포인터
		- 포인터는 변수(variable)이기 때문에 다른 주소를 참조할 수 있지만
		  배열은 상수(constant)이기 때문에 다른 주소를 참조할 수 없다.
		- 배열명은 포인터 상수이기때문에 ++ , -- 연산은 불가능하다.

		결론 : 포인터 변수는 다른 주소를 참조하거나 간접참조 연산자(*)를 통하여 값을 
			  변경할수 있지만, 배열은 포인터로 취급되긴 하나 포인터 상수이기때문에 다른 배열명이나
			  다른 변수의 주소를 저장할수없다. 또한 배열명으로 값을 변경을 한다거나 주소값을
			  이동하는 것은 잠깐 참조를 통하여 출력은 할수있으나 배열의 원래의 값은 변경되지않는다.

	*/

	int arr[10] = { 0 };
	int* aptr = arr;
	// 둘 다 주소를 저장하는 포인터이기 때문에 컴파일 에러는 발생하지 않는다.

	printf("arr = %p\n", arr);
	printf("aptr = %p\n", aptr);

	// 포인터는 단순히 저장공간의 주소를 저장하는 변수이므로
	// 할당된 크기가 8byte(64비트 운영체제 기준)이다.
	// 배열 또한 주소를 저장하나 일정 영역을 가진 상수이다.
	printf("sizeof(int) = %lld\n", sizeof(int));			// 4byte
	printf("sizeof(arr[0]) = %lld\n", sizeof(arr[0]));		// 4byte
	printf("sizeof(arr) = %lld\n", sizeof(arr));			// 40byte
	printf("sizeof(aptr) = %lld\n", sizeof(aptr));			// 8byte

	// 포인터는 변수이기 때문에 다른 주소를 참조 할 수 있다.
	aptr = NULL;
	// 배열은 상수이기 때문에 다른 주소를 참조할 수 없다.
	//  → 다른 메모리를 참조를 못할 뿐 참조하고 있는 
	//    메모리 내의 값은 수정이 가능하다.
	// arr = NULL; 컴파일 에러 발생
	arr[0] = 1000;

	//-------------------------------------------------------------------------

	int* ptr = arr;0
	printf("------------------------------\n");
	// 배열 식별자 앞에 포인터 연산자를 작성
	printf("arr[0] = %d\n", arr[0]);
	printf("*arr = %d\n", *arr);
	// → 배열 arr 에 저장된 값은 첫번째 원소의 주소이기 때문에
	//   포인터 연산자를 통해서 접근하면 첫번째 원소에 접근하여 값을 가져온다.
	printf("*ptr = %d\n", *ptr);

	printf("------------------------------\n");

	//---------------------------------------------------------------------------

	/*
		포인터의 산술 연산
	  - 산술 연산자 중에서 덧셈(+)과 뺄셈(-)의 좌측 피연산자가 포인터인 경우에
		포인터의 산술 연산이 되어진다.
	  - 포인터의 산술 연산은 포인터가 참조하는 저장 공간에서 우측 피연산자만큼
		이동한 곳의 주소를 반환하는 연산자
	  - 포인터의 자료형에 따라 이동하는 한 칸의 크기가 결정된다.
	*/

	int numbers[] = { 100,2,3,4,5,6,7 };
	ptr = numbers;
	// *numbers == numbers[0]

	printf("*(ptr + 1)     = %d\n", *(ptr + 1));
	printf("*(numbers + 1) = %d\n", *(numbers + 1));
	printf("numbers[1]     = %d\n", numbers[1]);
	// 컴파일러가 배열에서 사용되던 인덱스 연산자([])를 
	// 포인터 연산자와 포인터 산술 연산으로 해석한다.
	//   numbers[1] → *(numbers + 1)

	// 주의 할 점 
	//  소괄호를 통해서 우선순위를 명확히 해야한다.
	printf("*numbers + 1 = %d\n\n", *numbers + 1);
	// 인덱스 0인 원소에 1을 더한 값을 출력


	int length = sizeof(numbers) / sizeof(int);

	printf("numbers[0] = %p\n", &numbers[0]);
	// 포인터 변수인 ptr의 저장공간 크기가 8바이트이기때문에 인덱스가 증가할때마다 8바이트씩 증가한다.
	for (int i = 0; i < length; i++)
	{
		printf("numbers[%d] = %p\n", i, ptr + i);
		printf("numbers[%d] = %2d\n\n", i, *(ptr + i));
		ptr++;
	}
	return 0;
}