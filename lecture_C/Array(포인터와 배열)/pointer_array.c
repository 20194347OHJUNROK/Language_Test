#include <stdio.h>
/*
	* 배열과 포인터 배열의 차이점

	: 배열 같은 경우에는 인덱스의 개수가 정적이기때문에 지나치게 많은 공간을 확보하면 
	  배열요소가 차지하지않는 나머지 공간은 그대로 남기때문에 메모리 낭비가 심하다.

	:  그에 반해, 포인터 배열 같은 경우에는 문자열의 시작주소를 저장하기위한
	   별도의 포인터 배열공간만 확보되면 문자열의 시작주소를 통하여 배열 요소의 값으로
	   취할수 있기때문에 가변적이고 메모리 낭비가 없다.
	
	그러므로 문자열을 처리할때는 배열보다는 포인터 배열을 사용하는것이 메모리 낭비없이 공간을 효율적으로 사용할수있다.
	이렇게 메모리 공간을 문자열 상수의 길이에 따라 컴파일러가 널값을 포함하여 가변적으로 공간을 확보해주는데 이 확보된 문자열은
	문자열 상수이며 문자열 상수가 저장된 배열을 우리는  레그드(regged array)배열이라고 한다.
	또한, 포인터 배열 같은경우에는 배열이 포인터 상수이기때문에 다른 주소를 참조하거나 값을 변경할수없다.
	이를 해결하기위해서 우리는 이중포인터를 통하여 해결할수있다. 
	그 이유는 포인터 배열 또한 주소의 주소값을 담아 쓰기때문에 이중 포인터로 접근이 가능하다.
*/

int main()
{
	//  포인터 배열
	//  포인터들의 배열
	int n1 = 10;
	int n2 = 20;
	int* pArr[2] = { &n1, &n2 };
	// int* pArr[2] = { &n1, &n2 };
	//  pArr 의 데이터 타입 = int* 타입의 배열

	// printf("n1 = %d\n", pArr[0]);
	// = printf("n1 = %d\n", &n1);

	printf("n1의 값 = %d\n", *pArr[0]);
	printf("n1의 주소 = %p\n", pArr[0]);
	printf("n2의 값 = %d\n", *pArr[1]);
	printf("n2의 주소 = %p\n", pArr[1]);
	printf("----------------------------------------------\n\n");

//-----------------------------------------------------------------------------------------------------

	char* task[] = {
			"한국",
			"USA",
			"우주베키스탄",
			"나이지리아",
			"도미니카공화국",
			"EXIT"
	};

	printf("포인터 배열 task의 바이트 수 : %d\n", sizeof(task));
	printf("task[0]의 바이트 수 : %d\n\n", sizeof(task[0]));

	// 포인터 배열의 길이 구하기
	int length = sizeof(task) / sizeof(task[0]);

	// 포인터 배열의 주소값들을 출력
	for (int i = 0; i < length; i++)
	{
		printf("task[%d]의 주소 : %u\n", i, task[i]);
	}
	printf("----------------------------------------------\n\n");



	// 문자열 상수들의 값들을 출력
	for (int i = 0; i < length; i++)
	{
		printf("%2d번[%s]\t",i+1, task[i]);
	}
	printf("\n\n");


	int choice;
	while(1)
	{
		printf("번호 선택(1~6) : ");
		scanf("%d", &choice);

		if (choice < 1 || choice > 6)
		{
			printf("선택오류!!\n");
			printf("다시 입력해주세요.\n\n");
			continue; 
		}
		else if(choice==6)
		{
			printf("프로그램을 종료합니다.\n\n");
			exit(0);
		}
		else
		{
			printf("선택한 단어는 [%s]입니다.\n\n", task[choice-1]);
		}

	}


	return 0;
}